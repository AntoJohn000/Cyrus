# Cyrus
 
Key Features

Arithmetic Operations: Supports all basic arithmetic operations like addition, subtraction, multiplication, and division, enabling users to perform complex numerical calculations.
Relational & Logical Operations: Provides relational operators (e.g., <, >, <=, >=, ==, !=) and logical operators (e.g., AND, OR, NOT) for decision-making and control flow.
User-Defined Functions: Allows the creation of custom functions, making the language versatile and suitable for a variety of tasks, while encouraging code reusability.
Control Flow: Implements loop constructs (e.g., for, while) and conditional statements (if, else), giving users the ability to manage flow control effectively in their programs.

Development Process

During the development of Cyrus, I focused on:
Parser and Interpreter Design: Created a robust parser and interpreter to process and execute code, paying close attention to how the language translates high-level syntax into machine-readable instructions.
Testing and Debugging: Conducted comprehensive testing to ensure the stability and reliability of the language. This involved running a wide range of programs to validate the performance of the interpreter and ensure consistent handling of edge cases.
Optimization: Optimized the interpreter to improve execution efficiency, reducing runtime and ensuring smooth handling of both small-scale and larger, more complex scripts.

Key Learnings

Through this project, I deepened my understanding of how programming languages function at a lower level, particularly:

Code Interpretation: Gained insight into the steps involved in processing and interpreting code from tokens to executable actions.
Error Handling: Implemented error-handling mechanisms to provide meaningful feedback when users encounter syntax or runtime errors.
Memory Management: Developed a basic understanding of memory allocation and variable scoping within the languageâ€™s interpreter.
Future Improvements
There are several future enhancements planned for Cyrus, including:

Support for additional data types (e.g: dictionaries).
Integration of advanced error handling and debugging tools such as LLVM.
Performance optimizations, particularly for larger datasets or complex operations.
